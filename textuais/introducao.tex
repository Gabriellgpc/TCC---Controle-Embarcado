\chapter[Introdução]{Introdução}
\label{ch:introdução}
% [High-Performance Speed Control of Electric Machine Using Low-Precision Shaft Encoder]

% SPEED CONTROL through accurate speed detection is
% an essential requirement in the field of high-performance
% motion control like machine tool applications. An ordinary
% speed control uses average speed information as a speed
% feedback signal that is obtained by counting the increased
% number of encoder pulses during the detection time or the
% sampling interval [1]. However, the average speed information
% is not good enough to control the motor speed precisely
% because average detection lag is produced and the speed
% information is lost during the sampling interval, especially in
% a low-speed range when a low-precision shaft encoder is used.
% Therefore, instantaneous speed observers based on distur-
% bance torque observer have been reported as a better method
% to avoid unstable system which can be caused by making
% sampling time longer to obtain more encoder pulses [2]–[4].
% However, the observers do not have good noise-rejection prop-
% erties in noisy environment in comparison with the Kalman
% filter known as an optimal state estimator [5]. The Kalman
% filter is a stochastic estimator that possesses the smoothing
% properties and the noise-rejection capability robust to the
% process and measurement noise. Even though the Kalman filter


% [Low Speed Control of Permanent Magnet Synchronous Motor Based on Instantaneous Speed Estimation]

% Abstract - Incremental-type encoder is widely used for speed
% detection in servo system. However, the speed controller of the
% system usually becomes unstable at low speed range using
% average speed estimation method. An instantaneous speed
% estimation scheme for low speed control of permanent magnet
% synchronous motor is proposed. The speed estimation adopts a
% full order state observer to calculate feedback speed. The method
% can achieve good response because it is possible to detect the
% speed exactly without detection dead time. The observer design
% considerations for application are analyzed. Furthermore, inertia
% identification based on recursive extended least square algorithm
% is presented to reduce sensitivity of the speed estimation.
% Experimental results show that low speed control performance
% using the instantaneous speed estimation with inertia
% identification is superior to that of conventional one.

% [...]

% Presently, incremental-type encoder is the most
% typical speed and position sensor for servo system considering
% the cost and the performance. Speed detection using the
% encoder is calculated by counting the number of pulses
% generated by the encoder and interval between them [1], [2].
% This method detects the averaging speed, and therefore, it
% causes a detection dead time. Under low speed conditions,
% especially, where the interval between the pulses is wider than
% a speed control period, the detection dead time usually makes
% the speed controller unstable.

% To improve the performance of the speed control system
% which has been degraded by the detection dead time, several
% instantaneous speed observers have been proposed by using
% state observation theory. Instantaneous speed estimation using
% reduced-order disturbance torque observer has simple
% structure and easy to implement [3], [4]. But the gains of
% observer and controller are limited to increase in real
% application for mechanical noise and oscillation of system.
% Recently, a full order state estimation algorithm has been
% proposed which is based on the optimal state estimation theory
% like Kalman filter [5], [6]. But this scheme is complicated to
% implement since it needs large calculation.


% [Speed Measumment Using Rotary Encoders for High Performance ac Drive]
% Abstd - Most of high performance speed control of electrical
% motors, like ac Vector Conhol, use mtay encoders. The accuracy
% obtaining the mtor speed fmm encoder signals is an essential
% mquimment to achieve a good dynamic msponse, but it usually
% implies a delay in the speed conbol loop, which can cause stability
% problems.

% Ótimo Exemplo de "Trabalhos relacionados"
% A plenty of groundwork has been done for this
% paper and every important point that is to be
% highlighted is considered from previous literature.
% The book 'The 8051 Microcontroller and
% Embedded Systems Using Assembly and C, 2nd
% edition Mohammad Ali Mazidi, Janice Gillispie
% Mazidi, Rolin D. McKinlay presented the
% programming of microcontroller 8051 for the
% generation of pulses[I].The book 'Electrical
% Machines', P.S. Bimbra, Khanna Publishers
% presented the working principle of dc motor. And
% the methods of speed control of dc motor are
% explained [2].The book 'Fundamentals of Electric
% Drives', Gopal K. Dubey explained the pulse width
% modulation technique and the speed control of dc
% motor using pulse width modulation is explained.
% The effective output voltage can be varied by
% varying the duty cycle of the pulse [3].The book
% Micro Controller Architecture,
% 'The 8051
% Programming and Applications', Kenneth J.Ayala
% presented the ADC interfacing and LCD interfacing
% with the micro controller 8051 [4].

Em robótica móvel (mas não limitando-se) é comum o uso de controladores que possuem como saída as velocidades de giro que devem ser atingidas pelos conjuntos motor-roda do robô. Como por exemplo: controladores estabilizantes, seguidores de caminho e seguidores de trajetória. Portanto é essencial garantir que os motores tentem/consigam atingir essas velocidades, preferivelmente por meio do uso de controladores embarcados no robô. Com isso vem a necessidade do sensoriamento (\emph{Feedback}) e do processamento extra por parte do sistema embarcado do robô. O que pode se um problema em aplicações com baixo poder computacional e/ou restrições com relação ao uso de sensores de alta precisão. Sejam essas limitações econômicas ou estruturais.\\

\section{Contextualizando}
\label{sec:contextualizando}
% Main ref for this first sentence.  % [A Simple Speed Feedback System for Low Speed DC Motor Control in Robotic Applications] como ref. para o começo da intro.
Uma forma muito comum de acionamento de motores de corrente continua (CC) é por meio da modulação por largura de pulso, ou do inglês Pulse Width Modulation (PWM), que consiste basicamente em manipular a tensão média de alimentação do motor por meio de sinais digitais. É comum em certas aplicações o uso do sinal \emph{PWM} para manipular a velocidade do motor, ou seja, um controle de malha aberta, esse tipo de sistema apenas regula o quão rápido o motor irá girar. Porém na maioria das aplicações o controle em malha aberta não é suficiente, como por exemplo, não há garantias que se aplicado tensões iguais (\emph{PWM}) em ambos os motores de um robô com acionamento diferencial (robôs com duas rodas tracionadas e independentes) o movimento será estritamente linear \cite{simple_speed_feedback}, isso devi-se as diferenças entre os dois conjuntos de motores/rodas que fazem com que esses não girem a uma mesma velocidade, mesmo sobre uma mesma tensão.\\

Em contraste com o sistema de malha aberta, um sistema de malha fechada utiliza o sinal da saída da planta como \emph{Feedback} para realizar o controle. Esse tipo tende a manter a variável que se está controlando o mais próximo possível da referência desejada. Isso é feito usando a diferença entre a saída e a entrada (erro) como meio de controle. \\ %ta ruim essa explicação!

% [Speed Measurement Algorithms for Low-Resolution Incremental Encoder Equipped Drives: a Comparative Analysis]
Portando, ter-se um bom \emph{Feedback} em sistemas de controle em malha fechada é de extrema importância \cite{analise_incr_enc}, \cite{simple_speed_feedback}, tanto para se trabalhar em alta performance, quanto para garantir a estabilidade do sistema. No contexto de controle de rotação de motores, os sensores mais comuns são os codificadores de eixo (\emph{Encoders}). Os dois principais tipos são: \emph{Encoders} absolutos e os incrementais. O primeiro fornece a informação da posição angular absoluta e o segundo uma informação da variação de giro. \\

A resolução desses sensores influencia fortemente no desempenho e até mesmo na viabilidade do controlador, porém, sensores com resoluções maiores são, por consequência, mais caros, fazendo-se que seja necessário um \emph{Trade-off} \cite{analise_incr_enc}, \cite{low_precision_encoder01} entre custo e desempenho. Existem diversas técnicas que tentam melhorar a estimativa da velocidade sem que seja necessário o uso de sensores mais precisos, um tipo de técnica que geralmente é usada para esse fim são os estimadores/observadores de estado \cite{analise_incr_enc}, \cite{speed_observer_IA}, \cite{observer_speed}, que calculam uma estimativa da velocidade a partir dos dados do sensor e/ou de algum conhecimento sobre o comportamento do sistema. Porém, também há um \emph{Trade-off} com relação a qual estimador usar. Bons estimadores exigem mais poder computacional e/ou exigem que tenha-se mais conhecimento sobre a planta. O que pode ser um problema para certos tipos de aplicações, como é o caso de uma aplicação que deve rodar em um microcontrolador ($\mu$C) de um robô.\\

\section{Trabalhos Relacionados}
\label{sec:trabalhos_relacionados}
% \section{Estado da Arte}

O controle (embarcado ou não) de velocidade de motores e o estudo sobre observadores de estados voltados para estimação de velocidade, usando-se na maioria dos casos \emph{Encoders} incrementais como fonte de medição, são assuntos bastante estudados, tanto individualmente quanto em conjunto. No trabalho \cite{low_precision_encoder01} por exemplo, os autores demostram em seus resultados uma melhora no desempenho do controle de velocidade do motor usando-se uma técnica de mínimos quadrados recursiva (\emph{recursive least squares}) para fazer o ajuste automático (\emph{Auto tunning}) dos parâmetros do controlador e os parâmetros do observador de velocidade por filtro de \emph{Kalman}. Essa ideia de se empregar estimadores de velocidade/posição e o uso de técnicas para identificação automática de certos parâmetros do sistema também são explorados em \cite{LOW_SPEED_CONTROL}, \cite{Y_HORI_01} e \cite{Y_HORI_02}.\\

Em \cite{TOF:PIControl} os autores propõe um esquema de controle com dois graus de liberdade (equivalente ao \emph{Feedforward} + \emph{Backward}) de velocidade para servo motores equipados com \emph{Encoders} absolutos, com o objetivo de atingir uma boa relação entre a rejeição de perturbações e o rastreio da referência. Os autores também propõe o uso do filtro de \emph{Kalman} como estimar de estado.\\

Em \cite{analise_incr_enc} os autores apresentam uma análise comparativa entre diferentes técnicas para estimar a velocidade e posição de rotores equipados com \emph{Encoders}. O trabalho de \cite{quantization_error01} se assemelha a esse, porém as técnicas analisadas por este são apenas as abordagens mais clássicas.\\

% Microprocessor Based Closed Loop Speed
% Control of DC Motor U sing
% PWM
Em \cite{pwm_control} os autores apresentam um trabalho prático que implementa um sistema de controle de velocidade para motores CC usando um microcontrolador e sinal PWM como sinal de controle. Similarmente em \cite{embedded_control} os autores apresentam uma solução prática de um controle de velocidade de motores CC embarcado em um microcontrolador (ARM).\\

% Feedback–Feedforward Compensation of a DC
% Motor
O trabalho \cite{feedback_feedforward_control01} propõe e mostra bons resultados para o uso de um esquema de controle do tipo \emph{Feedforward} \emph{Feedback} para controle de velocidade de motores CC, com o objetivo de contornar os problemas do controlador PID (controlador \emph{Feedback}) com relação a oscilações e problemas com mudanças nos parâmetros desse controlador.\\

Diante do exposto, é notável que diferentes estratégias estão sendo implementadas com o mesmo intuito: De utilizar técnicas para aprimorar a informação proveniente de sensores de baixa precisão, com o objetivo de melhorar o controle de velocidade/posição de motores; Unir diferentes esquemas de controle com a intenção de somar os pontos fortes e compensar os fracos de cada um deles; E de aplicar esses métodos de forma a serem eficientes computacionalmente, para ser factível suas implementações em arquiteturas micro-controladas.

\section{Motivações e Objetivos}
% V2
% MOTIVAÇÃO!!!
Existem diversos desafios no projeto de robôs pequenos, além da questão mecânica, o tamanho reduzido também restringe a possibilidade de se usar \emph{Hardwares} com mais capacidade computacional, além dos tipos e a quantidade de sensores que podem ser usados. Robôs como os da equipe Poti de Futebol de robôs (do Departamento de Computação e Automação (DCA) da UFRN), que são voltados para a participação na \emph{Latin American Robotic Competition} (LARC) na categoria \emph{IEEE Very Small Size Soccer} (VSSS), têm dificuldades para conseguirem comportar um \emph{Hardware} capaz de executar um controle digital de velocidade para ambos os motores, além de possuírem sensores com uma baixa acurácia, dificultando assim o bom desempenho do sistema de controle.\\

O objetivo geral deste trabalho é projetar um sistema que realize o controle de velocidade dos motores de um robô com acionamento diferencial e que utiliza um estimador de velocidade ótimo sobre medições feitas com \emph{Encoders} de baixa resolução. Para a validação do trabalho foi feito a implementação do sistema proposto, testado em robôs reais e feito análises da eficiência dos controladores com relação a diminuição das assimetrias dos conjuntos motor-roda, bem como a qualidade da filtragem/estimativa da velocidade. %Os robôs utilizados foram desenvolvidos como parte do trabalho, por isso o detalhe de seu projeto também foi explorado.

% ****************************************************
% Intro à Robocup, IEEE VSSS e Equipe Poti
\section{Equipe Poti de Futebol de Robôs}
\label{sec:Equipe_Poti}

A Equipe Poti de Futebol de Robôs surgiu no Departamento de Engenharia de Computação e Automação da Universidade Federal do Rio Grande do Norte (DCA-UFRN), sendo participante na categoria \emph{IEEE Very Small Size Soccer}.\\

Nessa categoria duas equipes de 3 robôs de até 7,5 x 7,5 x 7,5cm jogam uma partida de futebol. Os robôs são controlados remotamente por um computador, mas sem intervenção humana \cite{VSSS}. O computador processa a imagem de uma câmera de vídeo colocada acima do campo e comanda os robôs. Na equipe Poti cada robô possui uma função no jogo, como: o goleiro, o atacante e o defensor, de forma que dependendo da estratégia de jogo eles podem se alternarem para melhor desempenho do time. A arquitetura do sistema do Futebol de Robôs do Time Poti é formada por vários módulos, sendo eles: visão, localização, estratégia, controle e transmissão.\\

O módulo de visão consiste de uma câmera que fotografa o campo com os jogadores e a bola, a taxa de captura da câmera é o fator que limita o tempo de amostragem de todo o sistema, atualmente a equipe utiliza uma taxa de amostragem de $100$ quadros/\emph{Frames} por segundo(FPS). O módulo de localização fornece a posição da bola e dos jogadores através das cores que foram predefinidas. O módulo de estratégia é responsável pelo próximo passe que os robôs deverão executar, a partir das imagens atuais. O módulo de controle é responsável por converte as referências de posição e orientação, definidas pela estratégia, em sinais que correspondem as velocidades que devem ser aplicadas nas rodas direita e esquerda de cada robô e o módulo de transmissão envia esse sinal para os robôs \cite{POTI}.\\

% O \textit{Hardware} projetado para esses robôs conta com um microcontrolador dual core de 32\emph{bits} da empresa \emph{Espressif Systems} (ESP32) e \textit{Encoders} magnéticos de $3$ pulsos por revolução por canal. Foi embarcado  nesse microcontrolador um controle de velocidade angular do tipo  \textit{FeedForward}/\textit{Backward}(PID), que deve atuar no par de motores dos robôs de  forma a controlar suas velocidades bem como reduzir as assimetrias entre  os motores direito e esquerdo.\\

% Usando a interface \textit{Bluetooth} presente no microcontrolador, foi criado um  protocolo simples de comunicação para realizar operações de telemetria e telecomando nos robôs. O \textit{Firmware} opera utilizando os dois núcleos  executando tarefas distintas: um núcleo é responsável pela comunicação  com o servidor, por meio do \textit{Bluetooth} e do protocolo criado, bem como  por tratar as interrupções geradas pelos \textit{Encoders} rotativos magnéticos;  já o outro núcleo executa a rotina de controle, com um período de amostragem de pelo menos $5$ms, para operar em uma frequência de pelo menos duas vezes mais rápido que o sistema que está rodando no \emph{Host}, que como já mencionado trabalha até à $100$Fps ($10$ms).\\

% Para medir a velocidade de rotação, foram utilizados \textit{Encoders} magnéticos  rotativos, com resolução de $3$ pulsos por canal por revolução do eixo do motor. Para diminuir a  incerteza na estimativa da velocidade, é aplicado um filtro de \textit{Kalman},  considerando a planta (motores) como um sistema de primeira ordem. Os  parâmetros da planta (constante de tempo, zona morta e ganho \emph{PWM} x  Velocidade angular) são estimados/calculados por mínimos quadrados na  rotina de calibração presente no \textit{Firmware}, sendo em seguida utilizados  para determinar os parâmetros do controlador.

\section{Estrutura do Trabalho}
\label{sec:estrutura_do_trabalho}
Este trabalho apresenta uma introdução sobre o tema, mostrando os fatores que motivam a implantação da ideia, além da justificativa e dos objetivos. Em sequência, o \autoref{ch:referencial_teorico} aborda os principais conceitos teóricos e técnicos utilizados no trabalho. O \autoref{ch:metodologia}, por sua vez, descreve os detalhes de organização e implementação de todas as partes do sistema proposto, bem como os procedimentos adotados para os testes e validação, enquanto o \autoref{ch:resultados} trata de mostrar os resultados obtidos experimentalmente e apresenta discussões a respeito destes resultados. Por fim, o \autoref{ch:conclusao} traz as principais conclusões e contribuições deste trabalho, bem como sugestões de trabalhos futuros.

% Organização do trabalho
% Este trabalhado é organizado da seguinte maneira: O Capítulo 1 corresponde à introdução do trabalho, por meio da qual é feita uma contextualização do problema e a proposta de solução para o mesmo; o capítulo 2 traz a fundamentação teórica utilizada para o desenvolvimento deste trabalho; no capítulo 3, os objetivos gerais e específicos são abordados; no capítulo 4 são apresentados os materiais e métodos utilizados para implementação do sistema; o capítulo 5 contém os resultados e discussões em que podem ser observadas as telas do sistema proposto; no capítulo 6 as conclusões deste trabalho são levadas em consideração, assim como sugestões de trabalhos futuros.